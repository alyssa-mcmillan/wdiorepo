#!/usr/bin/env node
"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const _ = require("lodash");
const os_1 = require("os");
const path_1 = require("path");
const path_2 = require("path");
const request = require("request");
const error_1 = require("../util/error");
const codeSignApi_1 = require("../codeSigning/codeSignApi");
const util_1 = require("util");
const NpmName_1 = require("../util/NpmName");
const readFileAsync = util_1.promisify(fs_extra_1.readFile);
const writeFileAsync = util_1.promisify(fs_extra_1.writeFile);
const removeFileAsync = util_1.promisify(fs_extra_1.remove);
const copyFileAsync = util_1.promisify(fs_extra_1.copy);
class PathGetter {
    constructor(target) {
        this._cwd = process.cwd();
        if (!target) {
            this._target = this._cwd;
        }
        else if (target && target.includes(this._cwd)) {
            this._target = target;
        }
        else {
            this._target = path_1.join(this._cwd, target);
        }
        this._packageJson = path_1.join(this._target, PathGetter.packageJson);
        this._packageJsonBak = path_1.join(this._target, `${PathGetter.packageJson}.bak`);
    }
    get packageJson() {
        return this._packageJson;
    }
    get packageJsonBak() {
        return this._packageJsonBak;
    }
    get target() {
        return this._target;
    }
    getFile(filename) {
        return path_1.join(this._target, filename);
    }
    getIgnoreFile(filename) {
        return path_1.join(this._cwd, filename);
    }
}
PathGetter.packageJson = 'package.json';
let cliUx;
let pathGetter;
exports.api = {
    /**
     * Validates that a url is a valid salesforce url.
     * @param url - The url to validate.
     */
    validateUrl(url) {
        try {
            // new URL throws if a host cannot be parsed out.
            if (!codeSignApi_1.validSalesforceHostname(url)) {
                // noinspection ExceptionCaughtLocallyJS
                throw new kit_1.NamedError('NotASalesforceHost', 'Signing urls must have the hostname developer.salesforce.com and use https.');
            }
        }
        catch (e) {
            if (e instanceof kit_1.NamedError) {
                throw e;
            }
            else {
                throw new error_1.InvalidUrlError(url, e);
            }
        }
    },
    /**
     * call out to npm pack;
     */
    pack() {
        return new Promise((resolve, reject) => {
            const command = 'npm pack -p';
            child_process_1.exec(command, { cwd: pathGetter.target }, (error, stdout, stderr) => {
                if (error && error['code']) {
                    return reject(new error_1.ExecProcessFailed(command, error['code'], stderr));
                }
                else {
                    const output = stdout.split(os_1.EOL);
                    if (output.length > 1) {
                        // note the output end with a newline;
                        const path = output[output.length - 2];
                        if (path && path.endsWith('tgz')) {
                            return resolve(pathGetter.getFile(path));
                        }
                        else {
                            return reject(new kit_1.NamedError('UnexpectedNpmFormat', `Npm pack did not return an expected tgz filename result: [${path}]`));
                        }
                    }
                    else {
                        return reject(new kit_1.NamedError('UnexpectedNpmFormat', `The output from the npm utility is unexpected [${stdout}]`));
                    }
                }
            });
        });
    },
    /**
     * verify a signature against a public key and tgz content
     * @param tarGzStream - Tar file to validate
     * @param sigFilenameStream - Computed signature
     * @param publicKeyUrl - url for the public key
     */
    verify(tarGzStream, sigFilenameStream, publicKeyUrl) {
        return new Promise((resolve, reject) => {
            const verifyInfo = new codeSignApi_1.CodeVerifierInfo();
            verifyInfo.dataToVerify = tarGzStream;
            verifyInfo.signatureStream = sigFilenameStream;
            const req = request.get(publicKeyUrl);
            codeSignApi_1.validateRequestCert(req);
            req.on('response', response => {
                if (response && response.statusCode === 200) {
                    verifyInfo.publicKeyStream = response;
                    return resolve(codeSignApi_1.verify(verifyInfo));
                }
                else {
                    return reject(new kit_1.NamedError('RetrievePublicKeyFailed', `Couldn't retrieve public key at url: ${publicKeyUrl} error code: ${response.statusCode}`));
                }
            });
            req.on('error', (err) => {
                if (err && err['code'] === 'DEPTH_ZERO_SELF_SIGNED_CERT') {
                    reject(new error_1.SignSignedCertError());
                }
                else {
                    reject(err);
                }
            });
        });
    },
    /**
     * sign a tgz file stream
     * @param fileStream - the tgz file stream to sign
     * @param privateKeyStream - the certificate's private key
     */
    retrieveSignature(fileStream, privateKeyStream) {
        const info = new codeSignApi_1.CodeSignInfo();
        info.dataToSignStream = fileStream;
        info.privateKeyStream = privateKeyStream;
        return codeSignApi_1.default(info);
    },
    /**
     * write the signature to a '.sig' file. this file is to be deployed to signatureurk
     * @param filePath - the file path to the tgz file
     * @param signature - the computed signature
     */
    async writeSignatureFile(filePath, signature) {
        if (!_.endsWith(filePath, 'tgz')) {
            throw new kit_1.NamedError('UnexpectedTgzName', `The file path ${filePath} is unexpected. It should be a tgz file.`);
        }
        cliUx.log(`Signing file at: ${filePath}`);
        const pathComponents = _.split(filePath, path_2.sep);
        const filenamePart = _.last(pathComponents);
        const sigFilename = _.replace(filenamePart, '.tgz', '.sig');
        await writeFileAsync(pathGetter.getFile(sigFilename), signature);
        return sigFilename;
    },
    /**
     * read the package.json file for the target npm to be signed.
     */
    retrievePackageJson() {
        return readFileAsync(pathGetter.packageJson, { encoding: 'utf8' });
    },
    /**
     * read the npm ignore file for the target npm
     * @param filename - local path to the npmignore file
     */
    retrieveIgnoreFile(filename) {
        return readFileAsync(pathGetter.getIgnoreFile(filename), { encoding: 'utf8' });
    },
    /**
     * checks the ignore content for the code signing patterns. *.tgz, *.sig package.json.bak
     * @param content
     */
    validateNpmIgnorePatterns(content) {
        const validate = (pattern) => {
            if (!content) {
                throw new kit_1.NamedError('MissingNpmIgnoreFile', 'Missing .npmignore file. The following patterns are required in for code signing: *.tgz, *.sig, package.json.bak.');
            }
            if (!_.includes(content, pattern)) {
                throw new kit_1.NamedError('MissingNpmIgnorePattern', `.npmignore is missing ${pattern}. The following patterns are required for code signing: *.tgz, *.sig, package.json.bak`);
            }
        };
        validate('*.tgz');
        validate('*.sig');
        validate('package.json.bak');
    },
    /**
     * checks the ignore content for the code signing patterns. *.tgz, *.sig package.json.bak
     * @param content
     */
    validateNpmFilePatterns(patterns) {
        const validate = (pattern) => {
            if (_.includes(patterns, pattern)) {
                throw new kit_1.NamedError('ForbiddenFilePattern', 'the files property in package.json should not include the following: *.tgz, *.sig, package.json.bak');
            }
        };
        validate('*.tgz');
        validate('*.sig');
        validate('package.json.bak');
    },
    /**
     * makes a backup copy pf package.json
     * @param src - the package.json to backup
     * @param dest - package.json.bak
     */
    copyPackageDotJson(src, dest) {
        return copyFileAsync(src, dest);
    },
    /**
     * used to update the contents of package.json
     * @param pJson - the updated json content to write to disk
     */
    writePackageJson(pJson) {
        return writeFileAsync(pathGetter.packageJson, JSON.stringify(pJson, null, 4));
    },
    /**
     * main method to pack and sign an npm.
     * @param args - reference to process.argv
     * @param ux - The cli ux interface usually provided by oclif.
     * @return {Promise<SigningResponse>} The SigningResponse
     */
    async doPackAndSign(args, ux) {
        const logger = await core_1.Logger.child('packAndSign');
        let packageDotJsonBackedUp = false;
        cliUx = ux;
        pathGetter = new PathGetter(args.target);
        try {
            logger.debug(`validating args.signatureurl: ${args.signatureurl}`);
            logger.debug(`validating args.publickeyurl: ${args.publickeyurl}`);
            exports.api.validateUrl(args.signatureurl);
            exports.api.validateUrl(args.publickeyurl);
            // read package.json info
            const packageJsonContent = await exports.api.retrievePackageJson();
            let packageJson = JSON.parse(packageJsonContent);
            logger.debug('parsed the package.json content');
            if (packageJson.files) {
                // validate that files property does not include forbidden patterns
                exports.api.validateNpmFilePatterns(packageJson.files);
            }
            else {
                // validate npm ignore has what we name.
                const npmIgnoreContent = await exports.api.retrieveIgnoreFile('.npmignore');
                exports.api.validateNpmIgnorePatterns(npmIgnoreContent);
                logger.debug('validated the expected npm ignore patterns');
            }
            // Recommend updating git ignore to match npmignore.
            const filename = '.gitignore';
            const gitIgnoreContent = await exports.api.retrieveIgnoreFile(filename);
            try {
                exports.api.validateNpmIgnorePatterns(gitIgnoreContent);
                logger.debug('validated the expected git ignore patterns');
            }
            catch (e) {
                cliUx.warn(`WARNING:  The following patterns are recommended in ${filename} for code signing: *.tgz, *.sig, package.json.bak.`);
            }
            // compute the name of the signature file
            const npmName = NpmName_1.NpmName.parse(packageJson.name);
            logger.debug(`parsed the following npmName components: ${JSON.stringify(npmName, null, 4)}`);
            npmName.tag = packageJson.version;
            const sigFilename = pathGetter.getFile(npmName.toFilename('.sig'));
            logger.debug(`using sigFilename: ${sigFilename}`);
            // make a backup of the signature file
            await exports.api.copyPackageDotJson(pathGetter.packageJson, pathGetter.packageJsonBak);
            logger.debug('made a backup of the package.json file.');
            packageDotJsonBackedUp = true;
            cliUx.log(`Backed up ${pathGetter.packageJson} to ${pathGetter.packageJsonBak}`);
            // update the package.json object with the signature urls and write it to disk.
            const sigUrl = `${args.signatureurl}${_.endsWith(args.signatureurl, '/') ? '' : '/'}${path_1.basename(sigFilename)}`;
            logger.debug(`sigUrl: ${sigUrl}`);
            packageJson = _.merge(packageJson, {
                sfdx: {
                    publicKeyUrl: args.publickeyurl,
                    signatureUrl: `${sigUrl}`
                }
            });
            await exports.api.writePackageJson(packageJson);
            cliUx.log('Successfully updated package.json with public key and signature file locations.');
            const filepath = await exports.api.pack();
            // create the signature file
            const signature = await exports.api.retrieveSignature(fs_extra_1.createReadStream(filepath, { encoding: 'binary' }), fs_extra_1.createReadStream(args.privatekeypath));
            logger.debug('created the digital signature');
            if (signature && signature.length > 0) {
                // write the signature file to disk
                await exports.api.writeSignatureFile(filepath, signature);
                cliUx.log(`Artifact signed and saved in ${sigFilename}`);
                let verified;
                try {
                    // verify the signature with the public key url
                    verified = await exports.api.verify(fs_extra_1.createReadStream(filepath, { encoding: 'binary' }), fs_extra_1.createReadStream(sigFilename), args.publickeyurl);
                }
                catch (e) {
                    cliUx.error(e);
                    throw new kit_1.NamedError('VerificationError', 'An error occurred trying to validate the signature. Check the public key url and try again.', e);
                }
                if (verified) {
                    cliUx.log(`Successfully verified signature with public key at: ${args.publickeyurl}`);
                    return {
                        tarPath: filepath,
                        filename: sigFilename,
                        verified,
                        name: packageJson.name,
                        version: packageJson.version
                    };
                }
                else {
                    // noinspection ExceptionCaughtLocallyJS
                    throw new kit_1.NamedError('FailedToVerifySignature', 'Failed to verify signature with tar gz content');
                }
            }
            else {
                // noinspection ExceptionCaughtLocallyJS
                throw new kit_1.NamedError('EmptySignature', 'The generated signature is empty. Verify the private key and try again');
            }
        }
        finally {
            // Restore the package.json file so it doesn't show a git diff.
            if (packageDotJsonBackedUp) {
                cliUx.log('Restoring package.json');
                await exports.api.copyPackageDotJson(pathGetter.packageJsonBak, pathGetter.packageJson);
                await removeFileAsync(pathGetter.packageJsonBak);
            }
        }
    },
    /**
     * Retrieve the fingerprint from a url where a cert is hosted
     * @param args - reference to process.argv
     */
    async retrieveFingerprint(publicKeyUrl) {
        return new Promise(resolve => {
            const req = request.get(publicKeyUrl);
            req.on('socket', (socket) => {
                socket.on('secureConnect', () => {
                    const fingerprint = socket.getPeerCertificate().fingerprint;
                    resolve({ fingerprint });
                });
            });
        });
    }
};
//# sourceMappingURL=packAndSign.js.map