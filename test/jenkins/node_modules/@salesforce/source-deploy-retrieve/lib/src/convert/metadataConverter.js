"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataConverter = void 0;
const types_1 = require("../collections/types");
const fs_1 = require("fs");
const path_1 = require("path");
const fileSystemHandler_1 = require("../utils/fileSystemHandler");
const streams_1 = require("./streams");
const errors_1 = require("../errors");
const collections_1 = require("../collections");
const registry_1 = require("../registry");
class MetadataConverter {
    constructor(registry = new registry_1.RegistryAccess()) {
        this.registry = registry;
    }
    convert(comps, targetFormat, output) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let cs;
                let components;
                if (comps instanceof collections_1.ComponentSet) {
                    cs = comps;
                    components = Array.from(comps.getSourceComponents());
                }
                else {
                    cs = new collections_1.ComponentSet(comps, this.registry);
                    components = comps;
                }
                let manifestContents;
                const isSource = targetFormat === 'source';
                const tasks = [];
                let writer;
                let mergeSet;
                let packagePath;
                let defaultDirectory;
                switch (output.type) {
                    case 'directory':
                        if (output.packageName) {
                            cs.fullName = output.packageName;
                        }
                        manifestContents = cs.getPackageXml();
                        packagePath = this.getPackagePath(output);
                        defaultDirectory = packagePath;
                        writer = new streams_1.StandardWriter(packagePath);
                        if (!isSource) {
                            const manifestPath = path_1.join(packagePath, MetadataConverter.PACKAGE_XML_FILE);
                            tasks.push(fs_1.promises.writeFile(manifestPath, manifestContents));
                            // For deploying destructive changes
                            if (cs.hasDeletes) {
                                const manifestFileName = this.getDestructiveManifestFileName(cs);
                                const destructiveManifestContents = cs.getPackageXml(undefined, true);
                                const destructiveManifestPath = path_1.join(packagePath, manifestFileName);
                                tasks.push(fs_1.promises.writeFile(destructiveManifestPath, destructiveManifestContents));
                            }
                        }
                        break;
                    case 'zip':
                        if (output.packageName) {
                            cs.fullName = output.packageName;
                        }
                        manifestContents = cs.getPackageXml();
                        packagePath = this.getPackagePath(output);
                        defaultDirectory = packagePath;
                        writer = new streams_1.ZipWriter(packagePath);
                        if (!isSource) {
                            writer.addToZip(manifestContents, MetadataConverter.PACKAGE_XML_FILE);
                            // For deploying destructive changes
                            if (cs.hasDeletes) {
                                const manifestFileName = this.getDestructiveManifestFileName(cs);
                                const destructiveManifestContents = cs.getPackageXml(undefined, true);
                                writer.addToZip(destructiveManifestContents, manifestFileName);
                            }
                        }
                        break;
                    case 'merge':
                        if (!isSource) {
                            throw new errors_1.LibraryError('error_merge_metadata_target_unsupported');
                        }
                        defaultDirectory = output.defaultDirectory;
                        mergeSet = new collections_1.ComponentSet();
                        // since child components are composed in metadata format, we need to merge using the parent
                        for (const component of output.mergeWith) {
                            mergeSet.add((_a = component.parent) !== null && _a !== void 0 ? _a : component);
                        }
                        writer = new streams_1.StandardWriter(output.defaultDirectory);
                        break;
                }
                const conversionPipeline = streams_1.pipeline(new streams_1.ComponentReader(components), new streams_1.ComponentConverter(targetFormat, this.registry, mergeSet, defaultDirectory), writer);
                tasks.push(conversionPipeline);
                yield Promise.all(tasks);
                const result = { packagePath };
                if (output.type === 'zip' && !packagePath) {
                    result.zipBuffer = writer.buffer;
                }
                else if (output.type !== 'zip') {
                    result.converted = writer.converted;
                }
                return result;
            }
            catch (e) {
                throw new errors_1.ConversionError(e);
            }
        });
    }
    getDestructiveManifestFileName(cs) {
        let manifestFileName;
        if (cs.getDestructiveChangesType() === types_1.DestructiveChangesType.POST) {
            manifestFileName = MetadataConverter.DESTRUCTIVE_CHANGES_POST_XML_FILE;
        }
        else {
            manifestFileName = MetadataConverter.DESTRUCTIVE_CHANGES_PRE_XML_FILE;
        }
        return manifestFileName;
    }
    getPackagePath(outputConfig) {
        let packagePath;
        const { genUniqueDir = true, outputDirectory, packageName, type } = outputConfig;
        if (outputDirectory) {
            if (packageName) {
                packagePath = path_1.join(outputDirectory, packageName);
            }
            else {
                if (genUniqueDir) {
                    packagePath = path_1.join(outputDirectory, `${MetadataConverter.DEFAULT_PACKAGE_PREFIX}_${Date.now()}`);
                }
                else {
                    packagePath = path_1.normalize(outputDirectory);
                }
            }
            if (type === 'zip') {
                packagePath += '.zip';
                fileSystemHandler_1.ensureDirectoryExists(path_1.dirname(packagePath));
            }
            else {
                fileSystemHandler_1.ensureDirectoryExists(packagePath);
            }
        }
        return packagePath;
    }
}
exports.MetadataConverter = MetadataConverter;
MetadataConverter.PACKAGE_XML_FILE = 'package.xml';
MetadataConverter.DESTRUCTIVE_CHANGES_POST_XML_FILE = 'destructiveChangesPost.xml';
MetadataConverter.DESTRUCTIVE_CHANGES_PRE_XML_FILE = 'destructiveChangesPre.xml';
MetadataConverter.DEFAULT_PACKAGE_PREFIX = 'metadataPackage';
//# sourceMappingURL=metadataConverter.js.map