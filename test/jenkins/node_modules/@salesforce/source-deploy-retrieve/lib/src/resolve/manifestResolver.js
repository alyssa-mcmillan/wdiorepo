"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestResolver = void 0;
const registry_1 = require("../registry");
const treeContainers_1 = require("./treeContainers");
const fast_xml_parser_1 = require("fast-xml-parser");
const utils_1 = require("../utils");
/**
 * Resolve MetadataComponents from a manifest file (package.xml)
 */
class ManifestResolver {
    constructor(tree = new treeContainers_1.NodeFSTreeContainer(), registry = new registry_1.RegistryAccess()) {
        this.tree = tree;
        this.registry = registry;
    }
    resolve(manifestPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const components = [];
            const file = yield this.tree.readFile(manifestPath);
            const parsedManifest = fast_xml_parser_1.parse(file.toString(), {
                stopNodes: ['version'],
            }).Package;
            const packageTypeMembers = utils_1.normalizeToArray(parsedManifest.types);
            const apiVersion = parsedManifest.version;
            for (const typeMembers of packageTypeMembers) {
                const typeName = typeMembers.name;
                for (const fullName of utils_1.normalizeToArray(typeMembers.members)) {
                    let type = this.registry.getTypeByName(typeName);
                    // if there is no / delimiter and it's a type in folders, infer folder component
                    if (type.folderType && !fullName.includes('/')) {
                        type = this.registry.getTypeByName(type.folderType);
                    }
                    components.push({ fullName, type });
                }
            }
            return { components, apiVersion };
        });
    }
}
exports.ManifestResolver = ManifestResolver;
//# sourceMappingURL=manifestResolver.js.map