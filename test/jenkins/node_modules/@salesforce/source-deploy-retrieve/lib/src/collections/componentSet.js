"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentSet = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const client_1 = require("../client");
const common_1 = require("../common");
const errors_1 = require("../errors");
const resolve_1 = require("../resolve");
const types_1 = require("./types");
const lazyCollection_1 = require("./lazyCollection");
const fast_xml_parser_1 = require("fast-xml-parser");
const core_1 = require("@salesforce/core");
const registry_1 = require("../registry");
/**
 * A collection containing no duplicate metadata members (`fullName` and `type` pairs). `ComponentSets`
 * are a convinient way of constructing a unique collection of components to perform operations such as
 * deploying and retrieving.
 *
 * Multiple {@link SourceComponent}s can be present in the set and correspond to the same member.
 * This is typically the case when a component's source files are split across locations. For an example, see
 * the [multiple package directories](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_mpd.htm)
 * scenario.
 */
class ComponentSet extends lazyCollection_1.LazyCollection {
    constructor(components = [], registry = new registry_1.RegistryAccess()) {
        super();
        this.components = new Map();
        // internal component maps used by this.getObject() when building manifests.
        this.destructiveComponents = new Map();
        this.manifestComponents = new Map();
        this.destructiveChangesType = types_1.DestructiveChangesType.POST;
        this.registry = registry;
        this.apiVersion = this.registry.apiVersion;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
        for (const component of components) {
            let asDeletion = false;
            if (component instanceof resolve_1.SourceComponent) {
                asDeletion = component.isMarkedForDelete();
            }
            this.add(component, asDeletion);
        }
    }
    static fromSource(input) {
        var _a, _b, _c;
        let fsPaths = [];
        let registry;
        let tree;
        let inclusiveFilter;
        let fsDeletePaths = [];
        if (Array.isArray(input)) {
            fsPaths = input;
        }
        else if (typeof input === 'object') {
            fsPaths = input.fsPaths;
            registry = (_a = input.registry) !== null && _a !== void 0 ? _a : registry;
            tree = (_b = input.tree) !== null && _b !== void 0 ? _b : tree;
            inclusiveFilter = input.include;
            fsDeletePaths = (_c = input.fsDeletePaths) !== null && _c !== void 0 ? _c : fsDeletePaths;
        }
        else {
            fsPaths = [input];
        }
        const resolver = new resolve_1.MetadataResolver(registry, tree);
        const set = new ComponentSet([], registry);
        const buildComponents = (paths, asDeletes) => {
            for (const path of paths) {
                for (const component of resolver.getComponentsFromPath(path, inclusiveFilter)) {
                    set.add(component, asDeletes);
                }
            }
        };
        buildComponents(fsPaths, false);
        buildComponents(fsDeletePaths, true);
        return set;
    }
    static fromManifest(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const manifestPath = typeof input === 'string' ? input : input.manifestPath;
            const options = (typeof input === 'object' ? input : {});
            const manifestResolver = new resolve_1.ManifestResolver(options.tree, options.registry);
            const manifest = yield manifestResolver.resolve(manifestPath);
            const resolveIncludeSet = options.resolveSourcePaths
                ? new ComponentSet([], options.registry)
                : undefined;
            const result = new ComponentSet([], options.registry);
            result.apiVersion = manifest.apiVersion;
            result.fullName = manifest.fullName;
            for (const component of manifest.components) {
                if (resolveIncludeSet) {
                    resolveIncludeSet.add(component);
                }
                const memberIsWildcard = component.fullName === ComponentSet.WILDCARD;
                if (!memberIsWildcard || options.forceAddWildcards || !options.resolveSourcePaths) {
                    result.add(component);
                }
            }
            if (options.resolveSourcePaths) {
                const components = ComponentSet.fromSource({
                    fsPaths: options.resolveSourcePaths,
                    tree: options.tree,
                    include: resolveIncludeSet,
                    registry: options.registry,
                });
                for (const component of components) {
                    result.add(component);
                }
            }
            return result;
        });
    }
    /**
     * Constructs a deploy operation using the components in the set and starts
     * the deployment. There must be at least one source-backed component in
     * the set to create an operation.
     *
     * @param options
     * @returns Metadata API deploy operation
     */
    deploy(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const toDeploy = Array.from(this.getSourceComponents());
            if (toDeploy.length === 0) {
                throw new errors_1.ComponentSetError('error_no_source_to_deploy');
            }
            const operationOptions = Object.assign({}, options, {
                components: this,
                registry: this.registry,
                apiVersion: this.apiVersion,
            });
            const mdapiDeploy = new client_1.MetadataApiDeploy(operationOptions);
            yield mdapiDeploy.start();
            return mdapiDeploy;
        });
    }
    /**
     * Constructs a retrieve operation using the components in the set and
     * starts the retrieval.
     *
     * @param options
     * @returns Metadata API retrieve operation
     */
    retrieve(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationOptions = Object.assign({}, options, {
                components: this,
                registry: this.registry,
                apiVersion: this.apiVersion,
            });
            const mdapiRetrieve = new client_1.MetadataApiRetrieve(operationOptions);
            yield mdapiRetrieve.start();
            return mdapiRetrieve;
        });
    }
    /**
     * Get an object representation of a package manifest based on the set components.
     *
     * @returns Object representation of a package manifest
     */
    getObject(forDestructiveChanges = false) {
        // If this ComponentSet has components marked for delete, we need to
        // only include those components in a destructiveChanges.xml and
        // all other components in the regular manifest.
        let components = this.components;
        if (this.hasDeletes) {
            if (forDestructiveChanges) {
                components = this.destructiveComponents;
            }
            else {
                components = this.manifestComponents;
            }
        }
        const typeMap = new Map();
        for (const key of components.keys()) {
            const [typeId, fullName] = key.split(ComponentSet.KEY_DELIMITER);
            let type = this.registry.getTypeByName(typeId);
            if (type.folderContentType) {
                type = this.registry.getTypeByName(type.folderContentType);
            }
            if (!typeMap.has(type.name)) {
                typeMap.set(type.name, []);
            }
            typeMap.get(type.name).push(fullName);
        }
        const typeMembers = [];
        for (const [typeName, members] of typeMap.entries()) {
            typeMembers.push({ members, name: typeName });
        }
        return {
            Package: {
                types: typeMembers,
                version: this.sourceApiVersion || this.apiVersion,
                fullName: this.fullName,
            },
        };
    }
    /**
     * Create a manifest in xml format based on the set components and the
     * type of manifest to create.
     *
     * E.g. package.xml or destructiveChanges.xml
     *
     * @param indentation Number of spaces to indent lines by.
     * @param forDestructiveChanges Whether to build a manifest for destructive changes.
     */
    getPackageXml(indentation = 4, forDestructiveChanges = false) {
        const j2x = new fast_xml_parser_1.j2xParser({
            format: true,
            indentBy: new Array(indentation + 1).join(' '),
            ignoreAttributes: false,
        });
        const toParse = this.getObject(forDestructiveChanges);
        toParse.Package[common_1.XML_NS_KEY] = common_1.XML_NS_URL;
        return common_1.XML_DECL.concat(j2x.parse(toParse));
    }
    /**
     * Get only the source-backed metadata components in the set.
     *
     * @param member Member to retrieve source-backed components for.
     * @returns Collection of source-backed components
     */
    getSourceComponents(member) {
        let iter;
        if (member) {
            // filter optimization
            const memberCollection = this.components.get(this.simpleKey(member));
            iter = (memberCollection === null || memberCollection === void 0 ? void 0 : memberCollection.size) > 0 ? memberCollection.values() : [];
        }
        else {
            iter = this;
        }
        return new lazyCollection_1.LazyCollection(iter).filter((c) => c instanceof resolve_1.SourceComponent);
    }
    add(component, asDeletion) {
        const key = this.simpleKey(component);
        if (!this.components.has(key)) {
            this.components.set(key, new Map());
        }
        if (component instanceof resolve_1.SourceComponent) {
            this.components.get(key).set(this.sourceKey(component), component);
            // Build maps of destructive components and regular components as they are added
            // as an optimization when building manifests.
            if (asDeletion) {
                component.setMarkedForDelete(true);
                this.logger.debug(`Marking component for delete: ${component.fullName}`);
                if (!this.destructiveComponents.has(key)) {
                    this.destructiveComponents.set(key, new Map());
                }
                this.destructiveComponents.get(key).set(this.sourceKey(component), component);
            }
            else {
                if (!this.manifestComponents.has(key)) {
                    this.manifestComponents.set(key, new Map());
                }
                this.manifestComponents.get(key).set(this.sourceKey(component), component);
            }
        }
    }
    /**
     * Tests whether or not a `fullName` and `type` pair is present in the set.
     *
     * A pair is considered present in the set if one of the following criteria is met:
     *
     * - The pair is directly in the set
     * - A wildcard component with the same `type` as the pair
     * - If a parent is attached to the pair and the parent is directly in the set
     * - If a parent is attached to the pair, and a wildcard component's `type` matches the parent's `type`
     *
     * @param component Component to test for membership in the set
     * @returns `true` if the component is in the set
     */
    has(component) {
        const isDirectlyInSet = this.components.has(this.simpleKey(component));
        if (isDirectlyInSet) {
            return true;
        }
        const wildcardMember = {
            fullName: ComponentSet.WILDCARD,
            type: typeof component.type === 'object' ? component.type.name : component.type,
        };
        const isIncludedInWildcard = this.components.has(this.simpleKey(wildcardMember));
        if (isIncludedInWildcard) {
            return true;
        }
        if (typeof component.type === 'object') {
            const { parent } = component;
            if (parent) {
                const parentDirectlyInSet = this.components.has(this.simpleKey(parent));
                if (parentDirectlyInSet) {
                    return true;
                }
                const wildcardKey = this.simpleKey({
                    fullName: ComponentSet.WILDCARD,
                    type: parent.type,
                });
                const parentInWildcard = this.components.has(wildcardKey);
                if (parentInWildcard) {
                    return true;
                }
            }
        }
        return false;
    }
    *[Symbol.iterator]() {
        for (const [key, sourceComponents] of this.components.entries()) {
            if (sourceComponents.size === 0) {
                const [typeName, fullName] = key.split(ComponentSet.KEY_DELIMITER);
                yield {
                    fullName,
                    type: this.registry.getTypeByName(typeName),
                };
            }
            else {
                for (const component of sourceComponents.values()) {
                    yield component;
                }
            }
        }
    }
    /**
     * If this `ComponentSet` has components marked for delete, this sets
     * whether those components are deleted before any other changes are
     * deployed (`destructiveChangesPre.xml`) or after changes are deployed
     * (`destructiveChangesPost.xml`).
     *
     * @param type The type of destructive changes to make; i.e., pre or post deploy.
     */
    setDestructiveChangesType(type) {
        this.destructiveChangesType = type;
    }
    /**
     * If this `ComponentSet` has components marked for delete it will use this
     * type to build the appropriate destructive changes manifest.
     *
     * @returns The type of destructive changes to make; i.e., pre or post deploy.
     */
    getDestructiveChangesType() {
        return this.destructiveChangesType;
    }
    /**
     * Each {@link SourceComponent} counts as an element in the set, even if multiple
     * ones map to the same `fullName` and `type` pair.
     *
     * @returns number of metadata components in the set
     */
    get size() {
        let size = 0;
        for (const collection of this.components.values()) {
            // just having an entry in the parent map counts as 1
            size += collection.size === 0 ? 1 : collection.size;
        }
        return size;
    }
    /**
     * Returns `true` if this `ComponentSet` contains components marked for deletion.
     */
    get hasDeletes() {
        return this.destructiveComponents.size > 0;
    }
    sourceKey(component) {
        const { fullName, type, xml, content } = component;
        return `${type.name}${fullName}${xml !== null && xml !== void 0 ? xml : ''}${content !== null && content !== void 0 ? content : ''}`;
    }
    simpleKey(component) {
        const typeName = typeof component.type === 'string' ? component.type.toLowerCase().trim() : component.type.id;
        return `${typeName}${ComponentSet.KEY_DELIMITER}${component.fullName}`;
    }
}
exports.ComponentSet = ComponentSet;
ComponentSet.WILDCARD = '*';
ComponentSet.KEY_DELIMITER = '#';
//# sourceMappingURL=componentSet.js.map